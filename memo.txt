  /* PRINT DE LA CONFIG */
                // std::cout << "PATH : " << parsedRequest.fullPathInfo << std::endl;
                // std::cout << "PORT CONFIG : ";
                // configForClient->printListen();
                // std::cout << "HOST NAME : " << configForClient->getServerName() << std::endl;
                /* FIN */    




/* TEST BOUCLE RECV SANS WHILE, AVEC TAILLE DE FD CONNUE À L'AVANCE */
// int     processSockets(int fd, WebservData &Data, char **env)
// {
//     struct stat buf;
//     fstat(fd, &buf);
//     off_t fdSize = buf.st_size;
//     std::cout << T_YB "SIZE OF FD = " T_N << fdSize << std::endl;

//     char    requestBuffer[fdSize];
//     int     running = 1;

//     if (isTabMaster(Data.getTabMaster(), fd) == 1)
//         processMasterSocket(Data, fd);
//     else
//     {
//         ssize_t len = recv(fd, requestBuffer, (fdSize), 0);
//         std::cout << "CHAR: [" << requestBuffer[0] << "]";

//         if (len < 0)
//             losingConnexion(fd, Data.getReadSet(), "Connexion lost... (");
//         else
//         {
//             requestBuffer[fdSize] = '\0';
//             std::cout << "\n22REQ BUFFER :\n" << requestBuffer;
// 			t_request	parsedRequest;
 
//             (void) env;

// 			parsedRequest = parsingRequest(requestBuffer);
//             Config *configForClient;
            
//             //std::cout << "Into configForClient, host: " << parsedRequest.host << std::endl;
//             configForClient = findConfigForClient(Data, parsedRequest.host);
//             const t_location  *locationForClient = NULL;
//             if (!configForClient)
//             {
//                 parsedRequest.statusCode = "400 Bad Request";
//                 parsedRequest.pathInfo = "./pages/400.html";
//             }
//             else
//             {
//                     locationForClient = findLocationForClient(*configForClient, parsedRequest);
//                     if (!locationForClient)
//                     {
//                         t_location  loc;
//                         loc.index = configForClient->getIndex("");
//                         loc.autoindex = 0;
//                         locationForClient = &loc;
//                     }
//                     (void) locationForClient;
    
//                     std::cout << "PATH : " << parsedRequest.fullPathInfo << std::endl; 
    
//                     // const t_location  *locationForClient;
//                     // to do :comparer les location et choisir la plus coherente
//                     // locationForClient = configForClient->getLocation("/"); // temporaire
//                     // if (locationForClient)
//                         // checkingHeader(&parsedRequest, locationForClient->method);
//                     // std::vector<std::string>    method;
//                     // method.push_back("GET");
//                     // checkingHeader(&parsedRequest, method);
//                     std::cout << "PORT CONFIG : ";
//                     configForClient->printListen();
//                     std::cout << "HOST NAME : " << configForClient->getServerName() << std::endl;              
//             }
//             // std::cout << T_GYB "Current status code [" << parsedRequest.statusCode << "]" << T_N << std::endl;

//             setContentDependingOnFileOrDirectory(parsedRequest, locationForClient);
             
//             std::string responseToClient = "HTTP/1.1 " +  parsedRequest.statusCode + "\nContent-Type:" + parsedRequest.fileType + "\nContent-Length:" 
//                                         + std::to_string(parsedRequest.fileContent.size()) + "\n\n" + parsedRequest.fileContent;
//             if (parsedRequest.pathInfo == "./exit.html") // (?)
//                 running = 0;
// 			std::cout << T_CB << "[" T_GNB << fd << T_CB "]" << " is requesting :" << T_N  << std::endl << requestBuffer << std::endl;
//             std::cout << "WE PRINT THE RESPONSE TO CLIENT HERE" << std::endl << T_YB << responseToClient.c_str() << T_N << "UNTIL HERE"<< std::endl;
//             std::cout << T_GYB "Current status code [" << parsedRequest.statusCode << "]" << T_N << std::endl;
//             fcntl(fd, F_SETFL, O_NONBLOCK);
//             if (send(fd, responseToClient.c_str(), responseToClient.size(), 0) < 0)
//                 error("Send", Data);
//             losingConnexion( fd, Data.getReadSet(), "Closing... [");
//         }
//     }
//     return (running);
// }

            /* LE SIEGE GOLDÉ = 6 caractères et le tour est joué */
            //std::cout << "CHAR: [" << requestBuffer[0] << "]";
            //std::cout << "      ";
            //std::cout << "CHAR: [" << std::endl;


/*
void checkingHeader(t_request *req, const std::vector<std::string> method)
{
    // struct stat file;

    // req->statusCode = "200 OK";
    // if (req->requestMethod.empty() == true || (req->requestMethod.compare("GET") != 0 
    //     && req->requestMethod.compare("POST") != 0
    //     && req->requestMethod.compare("DELETE") != 0))
    // if (((std::vector<std::string>)method).find(req->requestMethod) == method.end())
    
    // std::cout << T_GYB "Current status code [" << req->statusCode << "]" << T_N << std::endl;
    if( std::find(method.begin(), method.end(), req->requestMethod) == method.end() )
    {
        req->statusCode = "405 Method Not Allowed";
        std::cerr << T_YB "Wrong method" T_N << std::endl;
        req->fullPathInfo = "./pages/405.html"; // Add stat to check if the file is currently existant
    }
    // else if (req->protocol.compare(0, 8, "HTTP/1.1") != 0)
	// {
    //     req->statusCode = "400 Bad Request";
    //     std::cerr << T_YB "Wrong protocol HTTP/1.1" T_N << std::endl;
    //     req->fullPathInfo = "./pages/400.html";
	// }
    // else if (req->fullPathInfo.empty() == true || (stat((req->fullPathInfo).c_str(), &file)) != 0)
    // {
    //     req->statusCode = "404 Not Found";
    //     std::cerr << T_YB "Wrong file path" T_N << std::endl;
    //     req->fullPathInfo = "./pages/404.html";
    // }
}*/



//ORIGINAL
// void    takeBody(t_request *req, char *requestBuffer)
// {
//     int i;

//     i = strlen(requestBuffer);
//     while(i > 1 && requestBuffer[i] != '\n' && requestBuffer[i - 1] != '\n')
//         i--;
//     if (i > 1)
//     {
//         std::string str(requestBuffer);
//         req->body = str.substr(i, strlen(requestBuffer) - i);
//     }
// }